## Buffer
Q：为什么需要Buffer？
A：non-blocking模式中，核心思想是避免阻塞在read()/write()或其他IO系统调用上，从而更大限度提高线程的效率，使线程能够服务于多个socket连接。IO线程只阻塞在IO-multiplexing上（select/poll/epoll），因此对于一个socket连接，需要有发送和接收的缓冲：

- 发送时，程序想通过tcp发送100K byte，但在write中，OS只接收80K（操作系统有自己的缓冲控制），程序此时不应该原地阻塞等待发送，应该尽快交出控制权返回eventloop，那么需要有一个Buffer来接管剩余的20K数据，换句话说，程序本身只想尽快的把数据交出去，不关心底层是通过几次write()才完成，那么网络库就需要接管这些数据，保存到output buffer，注册POLLOUT事件，由epoll来通知可写事件，如果己方有数据且可写就发送数据，有数据不可写就交出控制权等待唤醒，无数据时就停止关注POLLOUT，以免造成busyloop。

- 接收时，由于tcp是无边界的字节流协议，容易出现“黏包”现象，接收方必须要处理“收到的数据不构成一条完整的消息”，“一次收到两条消息的数据”等情况

  针对这些情况，接收时一次性将内核缓冲区的数据读完存至input buffer，通过应用程序，由应用程序来判断这些数据能够构成自己想要的一个包，甚至是多个包，如果不够形成一个包，那就不取走数据，如果构成了相应的包，就取走这条消息，并进行相应的处理，重点在不够形成一个包的情况下，因为已经把数据读出来了，但是不够，所以需要找个地方暂存起来。同时一次性把socket中数据读完，是为了防止在LT模式下造成busyloop，在ET模式下造成数据漏读的情况。

